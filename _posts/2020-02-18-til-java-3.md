---
layout: post
title: "[TIL/Java] 자바 형변환, 연산자, 조건문과 반복문"
date: 2020-02-18 23:52:23 +0900
category: Java
comments: true
---



## 형변환

```
(타입)피연산자
```

* 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
* 괄호()는 '캐스트 연산자' 또는 '형변환 연산자'
* 피연산자의 값을 읽어서 지정된 타입으로 결과를 반환
* boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
* 기본형과 참조형은 서로 형변환할 수 없다.



#### 정수형간의 형변환

* 큰 타입에서 작은 타입으로의 변환 : 값 손실(loss of data) 발생 가능하다.
* 작은 타입에서 큰 타입으로의 변환 : 값 손실이 발생하지 않는다.

#### 실수형 간의 형변환

* float타입의 값을 double타입으로 변환 
  1. 지수는 float의 기저인 127을 뺀 후 double의 기저인 1023을 더해서 변환
  2. 가수는 float의 가수 23자리를 채우고 남은 자리를 0으로 채운다.

* double타입의 값을 float타입으로 변환
  1. 지수는 double의 기저인 1023을 뺀 후 float의 기저인 127을 더해서 변환
  2. 가수는 double의 가수 52자리 중 23자리만 저장되고 나머지는 버려진다.
* float타입의 범위를 넘는 값을 float으로 형변환 하는 경우 '무한대' 또는 '0'을 결과로 얻는다.
* 같은 값이어도 float과 double의 정밀도 차이 때문에 서로 다른 값이 저장된다.

#### 정수형과 실수형 간의 형변환

* 정수형을 실수형으로 변환 : 정수를 2진수로 변환한 다음, 정규화해서 실수의 저장 형식에 맞게 저장
  * double로 형변환해야 오차가 발생하지 않는다.
* 실수형을 정수형으로 변환 : 실수형의 소수점 이하 값은 버려진다.
  * 실수의 소수점을 버리고 남은 정수가 정수형의 저장범위를 넘는 경우 정수의 오버플로우가 발생한 결과를 얻는다.



### 자동 형변환

경우에 따라 편의상의 이유로 형변환 생략 가능

* 주의사항 : 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우 형변환을 생략하면 에러가 발생한다. (명시적 형변환의 경우 제외)

#### 자동 형변환의 규칙

기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.

* 표현범위가 좁은 타입에서 넓은 타입으로 형변환하려는 경우 값 손실이 없으므로 표현범위가 더 넓은 쪽으로 형변환된다.
* 좁은 타입으로의 변환은 반드시 형변환 연산자를 써줘야한다.



## 연산자

| 종류        | 연산자                 | 설명                                       |
| ----------- | ---------------------- | ------------------------------------------ |
| 산술연산자  | + - * / % << >>        | 사칙 연산과 나머지 연산                    |
| 비교 연산자 | > < >= <= == !=        | 크고 작음과 같고 다름을 비교               |
| 논리 연산자 | && \|\| ! & \| ^ ~     | '그리고(AND)'와 '또는(OR)'으로 조건을 연결 |
| 대입 연산자 | =                      | 우변의 값을 좌변에 저장                    |
| 기타        | (type)  ?:  instanceof | 형변환연산자, 삼항연산자, instanceof연산자 |



### 산술연산자

#### / (나누기)

* 피연산자가 정수형인 경우, 나누는 수로 0을 사용할 수 없다.
  * 0.0f, 0.0d로 나누는 것은 가능하지만 결과는 Infinity이다.
* 반올림하는 방법 : 0.5를 더해준다. 또는 Math.round()를 사용한다.

#### % (나머지)

* 피연산자의 부호를 모두 무시하고, 나머지 연산을 한 결과에 왼쪽 피연산자의 부호를 붙이면 된다.



### 비교연산자

#### '==' '!=' (등가비교)

* 연산을 수행하기 전에 형변환을 통해 피연산자의 타입을 같게 맞춘 다음 피연산자를 비교한다.
* 기본형과 참조형을 비교할 수 없다. (서로 형변환이 가능하지 않기 때문에)
* float타입의 값과 double타입의 값을 비교하는 두 가지 방법
  1. double타입의 값을 float타입으로 형변환한 다음에 비교한다.
  2. 어느 정도의 오차는 무시하고 두 타입의 값을 앞에서 몇 자리만 잘라서 비교한다.

#### 문자열의 비교

* `equals()` 메서드 사용
* `equalsIsIgnoreCase()` : 대소문자 구별하지 않고 비교



### 논리연산자

#### 효율적인 연산

* `&&` : 좌측 피연산자가 '거짓'이면, 우측 피연산자의 값은 평가하지 않는다.
* `||` : 좌측 피연산자가 '참'이면, 우측 피연산자의 값은 평가하지 않는다.
* 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 달라질 수 있다.



## 조건문

### if문

```
if (조건식) {
	// 조건식이 참(true)일 때 수행될 문장들
}
```

조건식이 참(true)이면 괄호{} 안의 문장들을 수행



#### if-else문

```
if (조건식) {
	// 조건식이 참(true)일 때 수행될 문장들
} else {
	// 조건식이 거짓(false)일 때 수행될 문장들
}
```



#### if-else if문

```
if (조건식1) {
	// 조건식1이 참(true)일 때 수행될 문장들
} else if (조건식2) {
	// 조건식2이 참(true)일 때 수행될 문장들
} else {
	// 위의 어떤 조건식도 만족하지 않을 때 수행될 문장들
}
```

처리해야할 경우의 수가 셋 이상인 경우, 한 문장에 여러 개의 조건식을 쓸 수 있는 if-else if문 사용



### switch문

```
switch(조건식) {
	case 값1 :
				// 조건식의 결과가 값1과 같을 경우 수행될 문장들
				break;
	case 값2 :
				// 조건식의 결과가 값2과 같을 경우 수행될 문장들
				break;
	// ...
	default :
				// 조건식의 결과와 일치하는 case문이 없을 때 수행될 문장들
}
```

* 동작 방식
  1. 조건식을 계산한다.
  2. 조건식의 결과와 일치하는 case문으로 이동한다.
  3. 이후의 문장들을 수행한다.
  4. break문이나 switch문의 끝을 만나면 switch문 전체를 빠져나간다.

* 제약조건
  1. switch문의 조건식 결과는 정수 또는 문자열이어야 한다.
  2. case문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다. (**문자 리터럴, 정수상수, 문자열 리터럴** 가능)

* 조건식을 잘 만들어서 case문의 갯수를 줄이는 것이 중요하다.



## 반복문

### for문

```
for (초기화; 조건식; 증감식) {
	// 조건식이 참일 때 수행될 문장들을 적는다.
}
```

* 수행 순서 

  초기화 > 조건식 > 문장들 > 증감식 > 조건들 > 문장들 > 증감식 > ...

* 초기화, 증감식에서 콤마`,`를 구분자로 둘 이상의 변수를 초기화하거나 두 문장 이상의 증감식을 쓸 수 있다.

* 세 가지 요소는 필요하지 않으면 생략할 수 있다.

  * 조건식이 생략된 경우 블럭 안에 if문을 넣어서 for문을 빠져나오게 해야 한다.



#### 향상된 for문

```
for (타입변수명 : 배열 또는 컬렉션) {
	// 반복할 문장
}
```

* 배열 또는 컬렉션에 저장된 값이 매 반복마다 하나씩 순서대로 읽혀서 변수에 저장된다.
* 반복문의 괄호 내에서는 이 변수를 사용해서 코드를 작성한다.



### while문

```
while (조건식) {
	// 조건식의 연산결과가 참(true)일 동안, 반복될 문장들
}
```

* 조건식을 먼저 평가해서 참(true)이면 블럭 내의 문장을 수행하고 다시 조건식으로 돌아가고, 거짓(false)이면 문장 전체를 벗어난다.

* 조건식을 생략할 수 없다.



### do-while문

```
do {
	// 조건식의 연산결과가 참(true)일 때 수행될 문장들
} while (조건식) ;
```

* 블럭{}을 먼저 수행한 후 조건식을 평가한다.
* `;`를 잊으면 안된다.



### break문

자신이 포함된 가장 가까운 반복문을 벗어난다.



### continue문

반복이 진행되는 도중에 continue문을 만나면 반복문의 끝으로 이동하여 다음 반복으로 넘어간다.



### 이름 붙은 반복문

하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다.

1. 중첩 반복문 앞에 이름을 붙인다.
2. break문과 continue문에 이름을 지정해준다.

```
Loop1 : while(true) {
			while(true) {
				break Loop1;
				break;
				continue Loop1;
				continue;
			}
}
```

