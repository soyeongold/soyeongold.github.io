---
layout: post
title: "[TIL/Java] 자바의 객체지향"
date: 2020-02-22 23:52:23 +0900
category: Java
comments: true
---



## 객체지향

기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가해서, 코드 간에 서로 관계를 맺어줌으로써 보다 유기적으로 프로그램을 구성할 수 있게 해준다.

#### 객체지향언어의 주요특징

```
1. 코드의 재사용성이 높다.
2. 코드의 관리가 용이하다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
```





## 클래스와 객체

### 클래스와 객체의 정의와 용도

* 클래스

**클래스의 정의** : 클래스란 객체를 정의해 놓은 것이다.

**클래스의 용도** : 클래스는 객체를 생성하는 데 사용된다.

* 객체

**객체의 정의**  : 객체는 실제로 존재하는 것, 사물 또는 개념

**객체의 용도** : 객체가 가지고 있는 기능과 속성에 따라 다르다.

프로그래밍에서의 객체 : 클래스에 정의된 내용대로 메모리에 생성된 것



### 객체와 인스턴스

* 인스턴스(instance) : 클래스로부터 만들어진 객체
* 인스턴스화(instantiate) : 클래스로부터 객체를 만드는 과정

예) 책상은 객체다. 책상은 책상 클래스의 인스턴스다.



### 객체의 구성요소 - 속성과 기능

* 객체는 속성과 기능의 집합이다. 
* 클래스란 객체를 정의한 것이므로, 클래스로부터 객체를 생성하면 클래스에 정의된 속성과 기능을 가진 객체가 만들어진다.
* 객체지향 프로그래밍에서의 표현
  * 속성(property) → 멤버변수(variable)
  * 기능(function) → 메서드(method)



### 인스턴스의 생성과 사용

#### 인스턴스 생성

```java
클래스명 변수명;
변수명 = new 클래스명();
```

#### 인스턴스 사용

```java
참조변수.멤버변수
```

* 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.
* 각 인스턴스의 속성(멤버변수)은 서로 다른 값을 가질 수 있으며, 메서드의 내용은 모든 인스턴스에 대해 동일하다.
* 둘 이상의 참조변수가 하나의 인스턴스를 가리키는(참조하는) 것은 가능하지만, 하나의 참조변수로 여러 개의 인스턴스를 가리키는 것은 가능하지 않다.

```java
class Tv {				// 클래스 선언
    // Tv의 속성
    int channel;		// 채널
    
    // Tv의 기능
    void channelUp() { ++channel; }
    void channelDown() { --channel; }
}

class TvTest {
    public static void main(String args[]) {
        Tv t1 = new Tv();		// t1 객체 생성
        // t1의 channel 인스턴스 사용
        System.out.println("t1의 channel 값은" + t1.channel + "입니다.");		
    }
}
```



### 객체 배열

* 객체를 배열로 다루는 것

#### 객체 배열 생성

```java
클래스명[] 객체명 = new 클래스명[배열길이];
Tv[] tvArr = new Tv[3];
```

#### 객체를 생성해서 객체 배열의 각 요소에 저장

```java
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
```

배열의 초기화 블럭 사용

```java
Tv[] tvArr = { new Tv(), new Tv(), new Tv() };
```

for문 사용

```java
for(int i=0; i < tvArr.length; i++) {
    tvArr[i] = new Tv();
}
```



### 클래스의 또 다른 정의

1. 클래스 - 데이터와 함수의 결합

   클래스는 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이다.

2. 클래스 - 사용자정의 타입

   프로그래밍 언어에서 제공하는 자료형 외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 사용자정의 타입이라고 한다.



## 변수와 메서드

### 변수의 종류

| 변수의 종류  |                         선언 위치                          |          생성시기           |
| :----------: | :--------------------------------------------------------: | :-------------------------: |
|  클래스변수  |                        클래스 영역                         | 클래스가 메모리에 올라갈 때 |
| 인스턴스변수 |                        클래스 영역                         |  인스턴스가 생성되었을 때   |
|   지역변수   | 클래스 영역 이외의 영역 (메서드, 생성자, 초기화 블럭 내부) | 변수 선언문이 수행되었을 때 |

* 인스턴스 변수
  * 인스턴스가 생성되었을 때 사용할 수 있다.
  * `객체이름.클래스변수` 형식으로 사용
  * 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.
* 클래스 변수
  * 인스턴스변수 앞에 static을 붙인 것
  * `클래스이름.클래스변수` 형식으로 사용
  * 클래스가 메모리에 올라갈 때 사용할 수 있다. (인스턴스를 생성하지 않아도 사용 가능)
  * `public`을 앞에 붙이면 '전역변수'의 성격을 갖는다. (프로그램 어디서나 접근 가능)
* 지역 변수
  * 자신이 속한 블럭{}을 벗어나면 소멸되어 사용할 수 없게 된다.



### 메서드

* 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
* 어떤 값을 입력하면 이 값으로 작업을 수행해서 결과를 반환한다.

#### 메서드의 선언과 구현

```
반환타입 메서드이름(타입 변수명, 타입 변수명, ...) {		// 메서드 선언부
    
    // 메서드 호출 시 수행될 코드 (메서드 구현부)
    
}
```

* **메서드 선언부** : 메서드가 작업을 수행하기 위해 어떤 값들을 필요로 하고 작업의 결과로 어떤 타입의 값을 반환하는 지에 대한 정보를 제공한다.
* 매개변수 선언(타입 변수명) 
  * 메서드가 작업을 수행하는데 필요한 값들을 제공받기 위한 것
  * 쉼표 `,`로 구분
  * 변수의 타입을 생략할 수 없다.
* 반환 타입 : 메서드의 작업수행 결과인 '반환값'의 타입을 적는다.

* **메서드 구현부** : 메서드를 호출했을 때 수행될 문장들을 적는다.
* return문 
  * 이 문장은 반환값을 호출한 메서드로 전달한다.
  * 반환값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 한다.
  * 단 하나의 값만 반환할 수 있다.
* 지역변수 : 메서드 내에 선언된 변수



#### 메서드의 호출

```
메서드이름(값1, 값2, ...);
```

* 인자와 매개변수 
  * 메서드를 호출할 때 괄호()안에 지정해준 값들
  * 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야 한다.
  * 인자의 타입은 매개변수의 타입과 일치하거나 자동형변환이 가능한 것이어야 한다.



#### return문

* 반환타입이 void인 경우, 생략 가능
* 반환타입이 void가 아닌 경우(반환값이 있는 경우), 생략 불가능

* 반환값 : 변수, 수식, 메서드, 조건연산자 등



### 매개변수의 유효성 검사

메서드의 구현부를 작성할 때, 가장 먼저 해야할 일이 매개변수의 값이 적절한지 확인하는 것이다.



### JVM의 메모리 구조

1. 메서드 영역

   * 클래스에 대한 정보 저장
   * 클래스 변수가 이 영역에 함께 생성

2. 힙

   * 인스턴스 변수들이 생성

3. 호출스택

   * 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당된다.
   * 메서드가 작업을 수행하는 동안, 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다.
   * 특징

   ```
   * 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
   * 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
   * 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
   * 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.
   ```



### 기본형 매개변수와 참조형 매개변수

**기본형 매개변수** : 변수의 값을 읽기만할 수 있다. (기본형 값이 복사되기 때문)

**참조형 매개변수** : 변수의 값을 읽고 변경할 수 있다. (인스턴스의 주소가 복사되기 때문)

* 매개변수가 '값이 저장된 주소'를 메서드에게 넘겨주어야 값을 읽어주는 것뿐만 아니라 변경하는 것도 가능하다.
* 메서드는 단 하나의 값만을 반환할 수 있지만 이것을 응용하면 여러 개의 값을 반환받는 것과 같은 효과를 얻을 수 있다.



### 참조형 반환타입

반환타입이 참조형이라는 것은 메서드가 `객체의 주소`를 반환한다는 것을 의미한다.



### 재귀호출(recursive call)

메서드의 내부에서 메서드 자신을 다시 호출하는 것

* 재귀 메서드(recursive method) : 재귀호출을 하는 메서드
* 조건문 필수 : 무한반복에 빠지지 않기 위해서 필요
* 재귀호출은 비효율적이므로 재귀호출에 드는 비용보다 재귀호출의 간결함이 주는 이득이 충분히 큰 경우에만 사용해야 한다.



### 클래스 메서드(static 메서드)와 인스턴스 메서드

* 클래스 메서드 : 메서드 앞에 static이 붙어 있는 메서드
  * 객체를 생성하지 않아도 호출 가능
  * `클래스이름.메서드이름(매개변수)` 형식으로 호출
  * 인스턴스 변수나 인스턴스 메서드 사용 불가
* 인스턴스 메서드 : 메서드 앞에 static이 붙어있지 않은 메서드
  * 객체를 생성해야만 호출 가능

```
1. 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있으면 static을 붙여준다.
2. 메서드 중에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static을 붙여줄 것을 고려한다.
```



### 클래스 멤버와 인스턴스 멤버 간의 참조와 호출

클래스멤버가 인스턴스멤버를 참조 또는 호출하고자하는 경우에는 인스턴스를 생성해야 한다.





## 오버로딩

한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것



### 오버로딩 조건

```
1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.
```

* 반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.



### 가변인자(varargs)와 오버로딩

메서드의 매개변수 개수를 동적으로 지정해줄 수 있다.

* 가변인자 선언 : `타입... 변수명`
* 매개변수 중에서 제일 마지막에 선언해야 한다.
* 인자가 아예 없어도 된다.
* 내부적으로 배열을 이용하여 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성된다.
* 가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출했을 때 구별되지 못하는 경우가 발생하기 쉽기 때문에 주의해야한다.





## 생성자

인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'

#### 생성자의 조건

```
1. 생성자의 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 리턴값이 없다.
```

* 오버로딩이 가능하다.



### 기본 생성자(default constructor)

소스파일의 클래스에 생성자가 하나도 정의되지 않은 경우, 컴파일러가 자동적으로 기본 생성자를 추가하여 컴파일한다.

```
클래스이름() { }
```

* 특별히 인스턴스 초기화 작업이 필요하지 않다면 사용



### 매개변수가 있는 생성자

호출 시 값을 넘겨받아서 인스턴스의 작업에 사용할 수 있다.

```java
Car c = new Car("black", "auto", 4);
```





### 생성자에서 다른 생성자 호출하기

생성자 간에도 서로 호출이 가능하다.

#### 생성자 간 호출 조건

```
1. 생성자의 이름으로 클래스 이름 대신 this를 사용하여 호출한다.
2. 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
```

* 생성자 내에서 초기화 작업 도중 다른 생성자를 호출하게 되면, 이전의 초기화 작업이 무의미해질 수 있기 때문에 첫 줄에서만 호출이 가능하다.
* 클래스 메서드(static메서드)에서 인스턴스가 존재하지 않을 수 있기 때문에 `this`를 사용할 수 없다.



### 생성자를 이용한 인스턴스의 복사

모든 인스턴스 변수(상태)를 동일한 값을 가질 수 있는 인스턴스를 하나 더 만들고자할 때 생성자를 이용할 수 있다.

```java
Car(Car c) {				// 매개변수를 객체로
    color = c.color;
    gearType = c.gear;
    door = c.door;
}

Car(Car c) {
    // Car(String color, String gearType, int door)를 호출
    Car(c.color, c.gearType, c.door);
}
```





## 변수의 초기화

* 변수를 선언하고 처음으로 값을 저장하는 것
* 멤버변수(클래스변수와 인스턴스변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.



### 멤버변수의 초기화 방법

1. 명시적 초기화
2. 생성자
3. 초기화 블럭
   * 인스턴스 초기화 블럭
   * 클래스 초기화 블럭



#### 명시적 초기화 (explicit initialization)

* 변수를 선언과 동시에 초기화하는 것
* 가장 기본적이면서도 간단한 초기화 방법 (우선적으로 고려)



#### 초기화 블럭 (initialization block)

```
클래스 초기화 블럭 : 클래스변수의 복잡한 초기화에 사용
인스턴스 초기화 블럭 : 인스턴스의 복잡한 초기화에 사용
```

* 초기화 작업이 복잡하여 명시적 초기화만으로는 부족한 경우 사용
* 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행
* 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때마다 수행



### 멤버변수의 초기화 시기와 순서

1. 클래스변수 초기화 : 기본값 → 명시적초기화 → 클래스 초기화 블럭
2. 인스턴스변수 초기화 : 기본값 → 명시적초기화 → 인스턴스 초기화 블럭 → 생성자

